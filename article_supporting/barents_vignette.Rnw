\documentclass{article}
\usepackage[T1]{fontenc}
\begin{document}

<<setup, cache = FALSE,echo=FALSE>>=
library(knitr)
opts_knit$set(eval.after = 'fig.cap', concordance=TRUE,
              root.dir="/home/hilaire.drouineau/Documents/Bordeaux/equipe estuaire/CaN") # evaluate fig.cap after the chunk
@



<<workingd, echo=FALSE>>=
library(xtable)
library(dplyr)
load("myCaNmod.rdata")
library(RCaN)
@


\section{loading the template to build the model}
Inputs should be provided in an xlxs data file. This file can be generated using RCaNGUI, but it can be created independently. An artificial file is provided in the package as a template. Here, we use the Barents Sea trophic food web example. The model is build using the \emph{build_CaNmod} function that reads the excel template file to build all the underlying matrices.

<<loading,eval=FALSE>>=
#first we load the library
library(RCaN)

#then we build the model
myCaNmod <- build_CaNmod("CaN_input_WGIBAR2020autumn.xlsx")
@

We can check that the 4 sheets of the template have been read correctly.

<<components, results="asis">>=
xtable(myCaNmod$components_param,"Components definition")
@

<<fluxes, results="asis">>=
xtable(myCaNmod$fluxes_def,"Fluxes definition")
@

<<series, results="asis">>=
xtable(as.data.frame(myCaNmod$series) %>%
               select(Year,DemersalFish_Biomass,DemersalFish_Landings,OmniZooplankton_Landings) %>%
               filter(Year<=1989 | Year >=2014) %>%
               add_row(.before=3) %>%
               mutate(Year=ifelse(is.na(Year),"...",Year)) %>%
               bind_cols(data.frame(`...`=rep(NA,5))),
       "Table of observations")
@


<<constraints, results="asis">>=
xtable(myCaNmod$constraints,"Constraints definition")
@


We can also chech the dimension of the constraints matrices.

<<dimmatrices>>=
#Dim of the inequality matrix (one row per constraint, one column per param)
dim(myCaNmod$A)

#Dim of the equality matrix (one row per constraint, one column per param)
dim(myCaNmod$C)

#the rownames stand for the constraint
head(rownames(myCaNmod$A))

#the colnames for the parameters
head(colnames(myCaNmod$C))
@


Constraints can be disactivated/reactivated using the \emph{toggle\_constraint} function. This facilitates the implementation of design of experiments.

<<toggle>>=
#disactivate constraints C02
myCaNmod <- toggle_constraint(myCaNmod, "C02")

#reactivate
myCaNmod <- toggle_constraint(myCaNmod, "C02")

#disactivate constraints C02 for year 1991
myCaNmod <- toggle_constraint(myCaNmod, "C02 : 1991")

#reactivate
myCaNmod <- toggle_constraint(myCaNmod, "C02 : 1991")
@


The linear relationship between fluxes and biomasses are described through these two matrices:

<<dimatricesbis>>=
# B=L.F (note that compare to Planque and Mullon B0 is treated as an unknownn
# parameter so that matrix M is included in L and F)
dim(myCaNmod$L)
@

\section{Exploring polytope}
The set of constraints define a convex polytope, i.e. a conspace subspace of a n-dimensional space (n corresponding to the number of the parameter) with flat faces. Each point inside the polytope is a possible solution of the model. The idea of Chance and Necessity model is to uniformly sample within those polytopes in order to explore the whole space of possible solutions. Nevertheless, the polytope should not be empty (otherwise, there is no solution) and preferentially should be bounded (otherwise a parameter can range to infinity). To check that the polytope is ok, you can use \emph{checkPolytopeStatusCaNmod} which will tell you the status of your polytope.


<<checkPolytopeStatusCaNmod>>=
checkPolytopeStatusCaNmod(myCaNmod)
@

If your polytope is not bounded, you should probably add additional constraints on not bounded parameter. To see which parameter is not bounded, you can use the function getAllBoundsParamCaNmod. An Inf in the upperbound column would correspond to a non bounded parameter, otherwise you have lower and upperbounds of each parameter

<<getAllBoundsParamCaNmod>>=
getAllBoundsParamCaNmod(myCaNmod)
@

Since this function can be time consuming, we provide a version that focus on a parameter of interest, here for example the first parameter:


<<getAllBoundsParamCaNmodsingle>>=
getBoundParamCaNmod(myCaNmod, p="Hzoo[1988]")
@


It can also be useful to the the polytope in the plane defined by two parameters. For example, if we want to see the bounds of \emph{Ozoo[1988]} and \emph{OZoo2OZoo[1988]} :
<<plot2dpolytope>>=
plotPolytope2DCaNmod(myCaNmod,
                     c("Ozoo[1988]", "HZoo2OZoo[1988]"))
@


If your polytope is empty, it means that there is no possible solutions and that some constraints should be relaxed. A function can help you to find which constraint raise problem: findingIncompatibleConstraintsCaNmod. For example, here we artificially add a constraint corresponding to a negative parameter and look at the result:



<<findingIncompatibleConstrCaNmod>>=
myCaNmod2 <- myCaNmod

#first param
colnames(myCaNmod$A)[1]

#we artificially add incompatible constraints (first param is negative)
myCaNmod2$A <- rbind(myCaNmod2$A,c(1,rep(0,ncol(myCaNmod2$A)-1)))
rownames(myCaNmod2$A)[nrow(myCaNmod2$A)]<-"neg_flow"
myCaNmod2$b <- c(myCaNmod2$b,-1)
incomp<-findingIncompatibleConstrCaNmod(myCaNmod2)
@


Here the first line tells you that the algorithm successfully fit the model by relaxing 2 constraints: "neg_flow" (the one we added) and constraint C06low for year 1988. This constraint sets the minimum value for hebivorous zooplankton biomass and clearly can not be satisfied if neg_flow is satisfied. Then, the next lines tell you that C06low is incompatible with neg_flow and and that neg_flow is incompatible on its own. So the next move would be to remove neg_flow.


\section{Fitting the model and exploring results}
The aim of this step is to achieve a uniform sampling within the convex polytope. RCaN provides two samplers but we recommend using the gibbs sampler (defaults). Since the sampling is based on a mcmc algorithm, it can be a good idea to run several independent chains. For example, here is the solution to run 2 chains in parrallel with 100 samples in each chain with a thinning of 1000:


<<runnning>>=
#Time start
begin = Sys.time()

#Running
res <- fitmyCaNmod(myCaNmod, N=100,thin=100, nchain=2,ncore=2)

#final time
end=Sys.time()

#duration
end-begin
@


The argument ncore allows to use several cores in parallel, however the library ensure that the computation leave one core unused and that the number of cores remain smaller than the number of chains

The return object contains the model description and a  mcmc.list object so that we can use all the diagnostics tools provided in the package coda, such traceplot, summary or gelman and rubin tests or autocorrelograms.


<<coda>>=
library(coda)
nchain(res$mcmc)
summary(res$mcmc)
traceplot(res$mcmc[,"PP2Bent[2011]"])
@

<<gelman>>=
gelman.diag(res$mcmc[,"PP2Bent[2011]"])
@

We can also do a posteriori thinning if required, for example if we chose to keep only one iteration on two:


<<thinning>>=
thin(res$mcmc)
#> [1] 1
thinned_res <- window(res$mcmc,thin=2)
thin(thinned_res)
acfplot(thinned_res[,"PP2Bent[2011]"])
@



The package provides a function that draws a ggplot of time series of biomass or flux. For example, here we draw a combination of time trends of "DemF", "DemF2Fishery" and "OZoo2PelF" with a log10 scale:


<<ggResult>>=
#the function returns a ggplot
g <- ggResult(res, c("DemF","DemF2Fishery","OZoo2PelF"), TRUE)

#this is a ggplot object so when can customize using ggplot2
library(ggplot2)
g + scale_y_log10() +
   guides(color = FALSE, fill = FALSE)
@

\end{document}
