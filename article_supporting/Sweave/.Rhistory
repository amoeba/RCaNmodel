#Define sectors to be used (households and non-profit institutions serving households)
sec="S14_S15"
#Download financial assets from Eurostat data (about household balance sheets: national currency, consolitated, 2015)
F_BS_raw = pdfetch_EUROSTAT("nasa_10_f_bs", UNIT="MIO_NAC", CO_NCO="CO", NA_ITEM=names, SECTOR=sec, TIME="2015", GEO="IT")
#Use/organise FA as a data frame
F_BS<-as.data.frame(F_BS_raw)
#Dowload non financial assets
NFA_BS_raw = pdfetch_EUROSTAT("nama_10_nfa_bs", UNIT="CP_MNAC", SECTOR=sec, GEO="IT", ASSET10=c("N111N","N2N"))  #instead of N1N and N2N, but the latter is empty
#Use/organise NFA as a data frame
NFA_BS<-as.data.frame(NFA_BS_raw)
#Create a 2x9 matrix representing the balance sheet
balancesheet<-matrix(0,ncol=2,nrow=10,dimnames = list(c("Produced NFA (dwellings)","Non-produced non-financial assets","Currency and deposits","Securities other than shares","Loans","Shares and other equity","Insurance technical reserves","Derivatives and empl. stock options","Other accounts receivable/payable","Net Worth"),c("Assets","Liabilities")))  #NOTE: I added derivatives
#Create a counter defining entries in the balance sheet
counter<-1
#Define and set names of non-financial assets (colnameA) - first two rows of matrix; NOTE: I used N111N istead of N1N
for(name in c("N111N","N2N")){
colnamea<-paste("A.CP_MNAC",sec,name,"IT",sep=".")
balancesheet[counter,1]<-NFA_BS[21,colnamea]  #21 instead of 18 (because 21 periods from 1995 to 2015)
counter<-counter+1
}
#Define and set the names of liabilities (colnameL) - rows 3 to 8 of matrix; NOTE: 7 instead of 6
for(name in names[1:7]){
colnamea<-paste("A.MIO_NAC.CO",sec,"ASS",name,"IT",sep=".")
colnamel<-paste("A.MIO_NAC.CO",sec,"LIAB",name,"IT",sep=".")
if(is.null(F_BS[21,colnamea]))
balancesheet[counter,1]<-0
else
balancesheet[counter,1]<-F_BS[21,colnamea]
if(is.null(F_BS[21,colnamea]))
balancesheet[counter,2]<-0
else
balancesheet[counter,2]<-F_BS[21,colnamel]
counter<-counter+1
}
#Define total - i.e. cell (10,2) - of balance sheet, as summation of net financial assets (BF90) and NFAs; NOTE: 10 instead of 9
balancesheet[10,2]<-F_BS[21,paste("A.MIO_NAC.CO",sec,"LIAB.BF90.IT",sep=".")]+NFA_BS[21,paste("A.CP_MNAC",sec,"N111N.IT",sep=".")] #+NFA_BS[20,paste("A.CP_MNAC",sec,"N2N.IT",sep=".")] #N111N instead of N1N
#Display the balance sheet
kable(balancesheet)
\subsection{Distribution. Fluxes}
\begin{figure}
\begin{center}
<<fig=true>>=
ggViolin(SAMPLE,POLYTOPE$flow,year=1990,TRUE) + xlab('Component') + ylab('Biomass')
@
\end{center}
\caption{Figure 11}
\label{Fig11}
\end{figure}
fluxZ <- paste(FLUXES[3,1],'[1990]',sep="")
gelman.diag(SAMPLE$mcmc[,fluxZ])
\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{authblk}
\title{ \bf{RCaN \\ \vspace{1cm} Supplementary Information \vspace{1cm}} }
\author[1]{Hilaire Drouineau}
\affil[1]{INRAE, Bordeaux, France}
\author[2]{Benjamin Planque}
\affil[2]{HI, Tromsoe, Norway}
\author[3]{Christian Mullon}
\affil[3]{IRD, MARBEC, Sete, France}
\begin{document}
\SweaveOpts{concordance=TRUE}
\maketitle
\section{Introduction}
In this Supplementary Information document, we present an example of a RCaN study. That is a concrete ecological question on a real ecosystem and then a sequence of RCaN-commands: their input, their output and their interpretation. The case study is that the Barents sea that has been presented in the main text. The RCaN file has been previously built, using the RCaN constructor; it is attached to this supplementary information. All following commands give rise to R-Markdown file that is also attached.
It is organized as follows:
\begin{enumerate}
\item We give a short glance at the RCaN-file.
\item Then we run main steps of the method after the construction of the RCaN file: build polytope, analyze polytope, compute sample, analyze sample.
\item Then after synthesizing the analysis of sample, we improve the set of constraints, and give the results of a second run after removing some constraints
\item Finally, we make comparisons between both runs and their interpretation
\end{enumerate}
\clearpage
\section{Preliminary: R Environment}
Firstly RCaN has to be downloaded. This is done once for all and the installation instructions are given in the ReadMe file.
Before running RCaN commands; a few libraries are to be loaded.
<<libraries>>=
library(RCaN) #the main package
library(ggplot2) #to draw results
library(coda) #to explore mcmc
library(dplyr) #to manipulate data frame
library(xtable) #to create latex tables
library(xlsx) # to import excel files
@
\clearpage
\section{The RCaN file}
Parameters, observations and constraints have been gathered in an Excel file with a specific structure.
<<label=data>>=
setwd('/Users/christianmullon/gitC/article_supporting/Sweave')
NAMEFILE <- 'BarentsSeaReconstructions_20210302.xlsx'
# NAMEFILE <- 'CaN_template_miniS.xlsx'
@
\clearpage
\subsection{Components}
How the list of components has been established? From witch knowledge? By whom?
<<label=components, eval=TRUE, results=tex, echo=FALSE>>=
COMPONENTS <- read.xlsx(NAMEFILE, 2)
print(xtable(COMPONENTS[,1:5],label="Components", caption = "Components"))
@
\clearpage
\subsection{Fluxes}
How the network has been designed? From which knowledge? By whom?
<<label=fluxes, eval=TRUE, results=tex, echo=FALSE>>=
FLUXES <- read.xlsx(NAMEFILE, 3)
print(xtable(FLUXES,label="Fluxes", caption = "Fluxes"))
@
$nf$ is the number of fluxes.
\clearpage
\subsection{Observations}
How observations have been collected? From which enquiries? By whom?
<<label=fluxes, eval=TRUE, results=tex, echo=FALSE>>=
OBSERVATIONS <- read.xlsx(NAMEFILE, 5)
print(xtable(OBSERVATIONS[1:20,1:5], label = "Observations", caption = "Observations"))
@
\clearpage
\subsection{Constraints}
How constraints have been designed? From which knowledge? By whom?
<<label=fluxes, eval=TRUE, results=tex, echo=FALSE>>=
CONSTRAINTS <- read.xlsx(NAMEFILE, 4)
print(xtable(CONSTRAINTS[1:20,1:2], label = "Constraints", caption="Constraints"))
@
\clearpage
\section{Building the polytope}
This is the first step. The polytope is defined by two pairs of a matrix and and a vector. $F$ being the vector of all flows at all timesteps, first one $(A,b)$ is an equality $ A.F = b$, second one $(C,v)$ is an eqality  $ C.F \le v$. This RCaN commands computes once for all thes matrices and vectors from the constrainst and the observations.
<<label=build>>=
system.time(POLYTOPE <- buildCaN(NAMEFILE))
summary(POLYTOPE)
@
\subsection{Structure of the polytope}
The polytope is defined inside a space with a very high number of dimensions. For the Barents sea example, we have:
<<label=dims>>=
dim(POLYTOPE$A)
length(POLYTOPE$b)
dim(POLYTOPE$C)
length(POLYTOPE$v)
@
In a general way: if $dim(C) = (x_C, y_C)$, $dim(A) = (x_A, y_A)$, $length(b) = l_b$, $  length(v) = l_v, then :
\begin{enumerate}
\item $ y_A = y_C $ is the dimension of the underlying space. $ x_A = l_b $ is the number of equality constraints; the proper dimension of the polytope is $ y_A - x_A$;
\item $y_C = y_A$ is the number of inequality constraints; this is the number of faces of the polytope.
\end{enumerate}
\clearpage
\subsection{Checking the polytope}
As it is defined in the RCaN file for the Barents' sea, the polytope is non-empty and bounded:
<<label=check>>=
checkPolytopeStatus(POLYTOPE)
@
\subsection{Bounds of the polytope}
Limits of the Barents' sea polytope in all dimensions are obtained with getAllBoundsParam. This is a time consuming command. Results are a vector with $nf \time nt$ components.
<<label=bounds>>=
# system.time(BOUNDS <- getAllBoundsParam(POLYTOPE, progressBar = FALSE))
# head(BOUNDS,10)
@
\subsection{Slices the polytope}
Function plotPolytope2D allows seeing the polytope in the plane defined by two parameters. In its first two dimensions, for the second 1990, the Barents sea polytope dimensions appears as.
\begin{figure}
\begin{center}
<<fig=true>>=
fluxX <- paste(FLUXES[5,1],'[1990]',sep="")
fluxY <- paste(FLUXES[7,1],'[1990]',sep="")
plotPolytope2D(POLYTOPE, c(fluxX, fluxY), progressBar=FALSE)
@
\end{center}
\caption{Figure 1}
\label{Fig01}
\end{figure}
\begin{figure}
\begin{center}
<<fig=true>>=
fluxX <- paste(FLUXES[4,1],'[1990]',sep="")
fluxY <- paste(FLUXES[12,1],'[1990]',sep="")
plotPolytope2D(POLYTOPE, c(fluxX, fluxY), progressBar=FALSE)
@
\end{center}
\caption{Figure 1}
\label{Fig1}
\end{figure}
\clearpage
\section{Sampling the polytope}
\subsection{Sampling}
The most important step of the method is the sampling of the polytope, that is the building many random possible trajectories. This is accomplished with the following RCaN command:
<<label=sample>>=
system.time(SAMPLE <- sampleCaN(POLYTOPE, N=100, thin=100, nchain=2, ncore=2))
@
\clearpage
\subsection{Convergence of the sample chains}
To check the mixing of the Monte Carlo Marko chain algorithm that is udes to build the sample, we use commands from the coda library.
<<label=nchain>>=
nchain(SAMPLE$mcmc)
# summary(SAMPLE$mcmc)
@
Gelman diagnostics. Gelman and Rubin (1992) propose a general approach to monitoring convergence of MCMC output in which $ m > 1$ parallel chains are run with starting values that are overdispersed relative to the posterior distribution. Convergence is diagnosed when the chains have `forgotten' their initial values, and the output from all chains is indistinguishable. The gelman.diag diagnostic is applied to a single variable from the chain. It is based a comparison of within-chain and between-chain variances, and is similar to a classical analysis of variance.
<<label=gelman>>=
fluxZ1 <- paste(FLUXES[3,1],'[1990]',sep="")
fluxZ2 <- paste(FLUXES[17,1],'[1990]',sep="")
fluxZ3 <- paste(FLUXES[22,1],'[1990]',sep="")
fluxZ4 <- paste(FLUXES[13,1],'[1990]',sep="")
gelman.diag(SAMPLE$mcmc[,fluxZ1])
gelman.diag(SAMPLE$mcmc[,fluxZ2])
gelman.diag(SAMPLE$mcmc[,fluxZ3])
gelman.diag(SAMPLE$mcmc[,fluxZ4])
@
\clearpage
Autocorrelation function. The autocorrelation function of the polytope sampling chains is illustrative of the independence of successive samples. If the samples are not serially correlated (which is desired) the autocorrelation should remain around zero (except for the first value which is always 1).
\begin{figure}
\begin{center}
<<fig=true>>=
library(cowplot)
fluxZ1 <- paste(FLUXES[3,1],'[1990]',sep="")
fluxZ2 <- paste(FLUXES[17,1],'[1990]',sep="")
fluxZ3 <- paste(FLUXES[22,1],'[1990]',sep="")
fluxZ4 <- paste(FLUXES[13,1],'[1990]',sep="")
g1 <- acfplot(SAMPLE$mcmc[,fluxZ1])
g2 <- acfplot(SAMPLE$mcmc[,fluxZ2])
g3 <- acfplot(SAMPLE$mcmc[,fluxZ3])
g4 <- acfplot(SAMPLE$mcmc[,fluxZ4])
plot_grid(
g1, g2, g3, g4,
ncol = 2,
nrow = 2,
labels = c('fluxZ1', 'fluxZ2', 'fluxZ3', 'fluxZ4'),
align="hv"
)
@
\end{center}
\caption{Figure 2}
\label{Fig2}
\end{figure}
# Chunk 1: libraries
library(RCaN) #the main package
library(ggplot2) #to draw results
library(coda) #to explore mcmc
library(dplyr) #to manipulate data frame
library(xtable) #to create latex tables
library(xlsx) # to import excel files
# Chunk 2: data
setwd('/Users/christianmullon/gitC/article_supporting/Sweave')
NAMEFILE <- 'BarentsSeaReconstructions_20210302.xlsx'
# NAMEFILE <- 'CaN_template_miniS.xlsx'
# Chunk 3: components
COMPONENTS <- read.xlsx(NAMEFILE, 2)
print(xtable(COMPONENTS[,1:5],label="Components", caption = "Components"))
# Chunk 4: fluxes
FLUXES <- read.xlsx(NAMEFILE, 3)
print(xtable(FLUXES,label="Fluxes", caption = "Fluxes"))
# Chunk 5: fluxes
OBSERVATIONS <- read.xlsx(NAMEFILE, 5)
print(xtable(OBSERVATIONS[1:20,1:5], label = "Observations", caption = "Observations"))
# Chunk 6: fluxes
CONSTRAINTS <- read.xlsx(NAMEFILE, 4)
print(xtable(CONSTRAINTS[1:20,1:2], label = "Constraints", caption="Constraints"))
# Chunk 7: build
system.time(POLYTOPE <- buildCaN(NAMEFILE))
summary(POLYTOPE)
# Chunk 8: dims
dim(POLYTOPE$A)
length(POLYTOPE$b)
dim(POLYTOPE$C)
length(POLYTOPE$v)
# Chunk 9: check
checkPolytopeStatus(POLYTOPE)
# Chunk 10: bounds
# system.time(BOUNDS <- getAllBoundsParam(POLYTOPE, progressBar = FALSE))
# head(BOUNDS,10)
# Chunk 11
fluxX <- paste(FLUXES[5,1],'[1990]',sep="")
fluxY <- paste(FLUXES[7,1],'[1990]',sep="")
plotPolytope2D(POLYTOPE, c(fluxX, fluxY), progressBar=FALSE)
# Chunk 12
fluxX <- paste(FLUXES[4,1],'[1990]',sep="")
fluxY <- paste(FLUXES[12,1],'[1990]',sep="")
plotPolytope2D(POLYTOPE, c(fluxX, fluxY), progressBar=FALSE)
# Chunk 13: sample
system.time(SAMPLE <- sampleCaN(POLYTOPE, N=100, thin=100, nchain=2, ncore=2))
# Chunk 14: nchain
nchain(SAMPLE$mcmc)
# summary(SAMPLE$mcmc)
# Chunk 15: gelman
fluxZ1 <- paste(FLUXES[3,1],'[1990]',sep="")
fluxZ2 <- paste(FLUXES[17,1],'[1990]',sep="")
fluxZ3 <- paste(FLUXES[22,1],'[1990]',sep="")
fluxZ4 <- paste(FLUXES[13,1],'[1990]',sep="")
gelman.diag(SAMPLE$mcmc[,fluxZ1])
gelman.diag(SAMPLE$mcmc[,fluxZ2])
gelman.diag(SAMPLE$mcmc[,fluxZ3])
gelman.diag(SAMPLE$mcmc[,fluxZ4])
# Chunk 16
library(cowplot)
fluxZ1 <- paste(FLUXES[3,1],'[1990]',sep="")
fluxZ2 <- paste(FLUXES[17,1],'[1990]',sep="")
fluxZ3 <- paste(FLUXES[22,1],'[1990]',sep="")
fluxZ4 <- paste(FLUXES[13,1],'[1990]',sep="")
g1 <- acfplot(SAMPLE$mcmc[,fluxZ1])
g2 <- acfplot(SAMPLE$mcmc[,fluxZ2])
g3 <- acfplot(SAMPLE$mcmc[,fluxZ3])
g4 <- acfplot(SAMPLE$mcmc[,fluxZ4])
plot_grid(
g1, g2, g3, g4,
ncol = 2,
nrow = 2,
labels = c('fluxZ1', 'fluxZ2', 'fluxZ3', 'fluxZ4'),
align="hv"
)
# Chunk 17
fluxZ <- paste(FLUXES[13,1],'[1990]',sep="")
acfplot(SAMPLE$mcmc[,fluxZ],ylim=c(-1,1))
# Chunk 18
fluxZ <- paste(FLUXES[17,1],'[1990]',sep="")
acfplot(SAMPLE$mcmc[,fluxZ],ylim=c(-1,1))
# Chunk 19
fluxZ <- paste(FLUXES[23,1],'[1990]',sep="")
acfplot(SAMPLE$mcmc[,fluxZ],ylim=c(-1,1))
# Chunk 20
g <- ggSeries(SAMPLE, POLYTOPE$species, TRUE)
g + scale_y_log10() + guides(color = FALSE, fill = FALSE)
# Chunk 21
g <- ggSeries(SAMPLE, POLYTOPE$flow, TRUE)
g + scale_y_log10() + guides(color = FALSE, fill = FALSE)
# Chunk 22
ggViolin(SAMPLE,POLYTOPE$species,year=1990,TRUE) + xlab('Component') + ylab('Biomass')
# Chunk 23
ggViolin(SAMPLE,POLYTOPE$species,year=1990,TRUE) + xlab('Component') + ylab('Biomass')
# Chunk 24
ggViolin(SAMPLE,POLYTOPE$flow,year=1990,TRUE) + xlab('Component') + ylab('Biomass')
# Chunk 25
ggDiet(SAMPLE, POLYTOPE$species) + ylab('prey proportion in the diet')
# Chunk 26
ggGrowth(SAMPLE, POLYTOPE$species)
# Chunk 27
ggTrophicRelation(SAMPLE, POLYTOPE$species[3:5])
# ggTrophicRelation(SAMPLE, compB)
# Chunk 28
ggTrophicRelation(SAMPLE, POLYTOPE$species)
# ggTrophicRelation(SAMPLE, compB)
# Chunk 29
ggSatiation(SAMPLE, POLYTOPE$species)
# Chunk 30
ggSatiatInertia(SAMPLE, POLYTOPE$species)
# Chunk 31
ggPairsBiomass(SAMPLE,logscale=FALSE)
# Chunk 32
ggPairsBiomass(SAMPLE,POLYTOPE$species[c(5,6)],logscale=FALSE)
# Chunk 33: toggle
# disactivate constraints C08 : Max pelagic catches
constA <- CONSTRAINTS[8,1]
constA
POLYTOPEA <- toggleConstraint(POLYTOPE, constA)
# Chunk 34: checknew
checkPolytopeStatus(POLYTOPEA)
# Chunk 35: sampleNew
system.time(SAMPLEA <- sampleCaN(POLYTOPEA, N=100, thin=100, nchain=2, ncore=2))
# Chunk 36
fluxX <- FLUXES[1,1]
fluxY <- FLUXES[2,1]
compA <- COMPONENTS[2,1]
compB <- COMPONENTS[3,1]
c(fluxX,fluxY,compA)
g <- ggSeries(SAMPLEA, POLYTOPEA$species, TRUE)
g + scale_y_log10() + guides(color = FALSE, fill = FALSE)
library(cowplot)
fluxZ1 <- paste(FLUXES[3,1],'[1990]',sep="")
fluxZ2 <- paste(FLUXES[17,1],'[1990]',sep="")
fluxZ3 <- paste(FLUXES[22,1],'[1990]',sep="")
fluxZ4 <- paste(FLUXES[13,1],'[1990]',sep="")
g1 <- acfplot(SAMPLE$mcmc[,fluxZ1])
g2 <- acfplot(SAMPLE$mcmc[,fluxZ2])
g3 <- acfplot(SAMPLE$mcmc[,fluxZ3])
g4 <- acfplot(SAMPLE$mcmc[,fluxZ4])
plot_grid(
g1, g2, g3, g4,
ncol = 2,
nrow = 2,
labels = c('fluxZ1', 'fluxZ2', 'fluxZ3', 'fluxZ4'),
align="hv"
)
library(RCaN) #the main package
library(ggplot2) #to draw results
library(coda) #to explore mcmc
library(dplyr) #to manipulate data frame
library(xtable) #to create latex tables
library(xlsx) # to import excel files
library(cowplot)
p1 <- ggplot(mtcars, aes(disp, mpg)) +
geom_point()
p2 <- ggplot(mtcars, aes(qsec, mpg)) +
geom_point()
plot_grid(p1, p2, labels = c('A', 'B'))
# Chunk 1: libraries
library(RCaN) #the main package
library(ggplot2) #to draw results
library(coda) #to explore mcmc
library(dplyr) #to manipulate data frame
library(xtable) #to create latex tables
library(xlsx) # to import excel files
library(cowplot)
# Chunk 2: data
setwd('/Users/christianmullon/gitC/article_supporting/Sweave')
NAMEFILE <- 'BarentsSeaReconstructions_20210302.xlsx'
# NAMEFILE <- 'CaN_template_miniS.xlsx'
# Chunk 3: components
COMPONENTS <- read.xlsx(NAMEFILE, 2)
print(xtable(COMPONENTS[,1:5],label="Components", caption = "Components"))
# Chunk 4: fluxes
FLUXES <- read.xlsx(NAMEFILE, 3)
print(xtable(FLUXES,label="Fluxes", caption = "Fluxes"))
# Chunk 5: fluxes
OBSERVATIONS <- read.xlsx(NAMEFILE, 5)
print(xtable(OBSERVATIONS[1:20,1:5], label = "Observations", caption = "Observations"))
# Chunk 6: fluxes
CONSTRAINTS <- read.xlsx(NAMEFILE, 4)
print(xtable(CONSTRAINTS[1:20,1:2], label = "Constraints", caption="Constraints"))
# Chunk 7: build
system.time(POLYTOPE <- buildCaN(NAMEFILE))
summary(POLYTOPE)
# Chunk 8: dims
dim(POLYTOPE$A)
length(POLYTOPE$b)
dim(POLYTOPE$C)
length(POLYTOPE$v)
# Chunk 9: check
checkPolytopeStatus(POLYTOPE)
# Chunk 10: bounds
system.time(BOUNDS <- getAllBoundsParam(POLYTOPE, progressBar = FALSE))
head(BOUNDS,10)
# Chunk 11
nX1 <- FLUXES[5,1]
nY1 <- FLUXES[8,1]
fluxX1 <- paste(nX1,'[1990]',sep="")
fluxY1 <- paste(nY1,'[1990]',sep="")
g1 <- plotPolytope2D(POLYTOPE, c(fluxX1, fluxY1), progressBar=FALSE)
nX2 <- FLUXES[3,1]
nY2 <- FLUXES[12,1]
fluxX2 <- paste(nX2,'[1990]',sep="")
fluxY2 <- paste(nY2,'[1990]',sep="")
# Chunk 12: sample
system.time(SAMPLE <- sampleCaN(POLYTOPE, N=100, thin=100, nchain=2, ncore=2))
# Chunk 13: nchain
nchain(SAMPLE$mcmc)
summary(SAMPLE$mcmc)
# Chunk 14: gelman
fluxZ1 <- paste(FLUXES[3,1],'[1990]',sep="")
fluxZ2 <- paste(FLUXES[17,1],'[1990]',sep="")
fluxZ3 <- paste(FLUXES[22,1],'[1990]',sep="")
fluxZ4 <- paste(FLUXES[13,1],'[1990]',sep="")
gelman.diag(SAMPLE$mcmc[,fluxZ1])
gelman.diag(SAMPLE$mcmc[,fluxZ2])
gelman.diag(SAMPLE$mcmc[,fluxZ3])
gelman.diag(SAMPLE$mcmc[,fluxZ4])
# Chunk 15
fluxZ1 <- paste(FLUXES[3,1],'[1990]',sep="")
fluxZ2 <- paste(FLUXES[17,1],'[1990]',sep="")
fluxZ3 <- paste(FLUXES[22,1],'[1990]',sep="")
fluxZ4 <- paste(FLUXES[13,1],'[1990]',sep="")
g1 <- acfplot(SAMPLE$mcmc[,fluxZ1])
g2 <- acfplot(SAMPLE$mcmc[,fluxZ2])
g3 <- acfplot(SAMPLE$mcmc[,fluxZ3])
g4 <- acfplot(SAMPLE$mcmc[,fluxZ4])
plot_grid(g1, g2, g3, g4, ncol = 2, nrow = 2,
labels = c('fluxZ1', 'fluxZ2', 'fluxZ3', 'fluxZ4'), align="hv")
# Chunk 16
fluxZ <- paste(FLUXES[13,1],'[1990]',sep="")
acfplot(SAMPLE$mcmc[,fluxZ],ylim=c(-1,1))
# Chunk 17
fluxZ <- paste(FLUXES[17,1],'[1990]',sep="")
acfplot(SAMPLE$mcmc[,fluxZ],ylim=c(-1,1))
# Chunk 18
fluxZ <- paste(FLUXES[23,1],'[1990]',sep="")
acfplot(SAMPLE$mcmc[,fluxZ],ylim=c(-1,1))
# Chunk 19
g <- ggSeries(SAMPLE, POLYTOPE$species, TRUE)
g + scale_y_log10() + guides(color = FALSE, fill = FALSE)
# Chunk 20
g <- ggSeries(SAMPLE, POLYTOPE$flow, TRUE)
g + scale_y_log10() + guides(color = FALSE, fill = FALSE)
# Chunk 21
ggViolin(SAMPLE,POLYTOPE$species,year=1990,TRUE) + xlab('Component') + ylab('Biomass')
# Chunk 22
ggViolin(SAMPLE,POLYTOPE$species,year=1990,TRUE) + xlab('Component') + ylab('Biomass')
# Chunk 23
ggViolin(SAMPLE,POLYTOPE$flow,year=1990,TRUE) + xlab('Component') + ylab('Biomass')
# Chunk 24
ggDiet(SAMPLE, POLYTOPE$species) + ylab('prey proportion in the diet')
# Chunk 25
ggGrowth(SAMPLE, POLYTOPE$species)
# Chunk 26
ggTrophicRelation(SAMPLE, POLYTOPE$species[3:5])
# Chunk 27
ggTrophicRelation(SAMPLE, POLYTOPE$species)
# Chunk 28
ggSatiation(SAMPLE, POLYTOPE$species)
# Chunk 29
# Chunk 30
ggPairsBiomass(SAMPLE,logscale=FALSE)
# Chunk 31
ggPairsBiomass(SAMPLE,POLYTOPE$species[c(5,6)],logscale=FALSE)
# Chunk 32: toggle
# disactivate constraints C08 : Max pelagic catches
constA <- CONSTRAINTS[8,1]
constA
POLYTOPEA <- toggleConstraint(POLYTOPE, constA)
# Chunk 33: checknew
checkPolytopeStatus(POLYTOPEA)
# Chunk 34: sampleNew
system.time(SAMPLEA <- sampleCaN(POLYTOPEA, N=100, thin=100, nchain=2, ncore=2))
# Chunk 35
fluxX <- FLUXES[1,1]
fluxY <- FLUXES[2,1]
compA <- COMPONENTS[2,1]
compB <- COMPONENTS[3,1]
c(fluxX,fluxY,compA)
g <- ggSeries(SAMPLEA, POLYTOPEA$species, TRUE)
g + scale_y_log10() + guides(color = FALSE, fill = FALSE)
